; Node Operations
;
; Govern staking, node registration, and the reverse of both of those operations.
;
; See https://paper.dropbox.com/doc/Node-Operations-Rules-Proposal--AgKAV7c_y9Wi4HIPGd6UVydGAQ-fQtSgwmn07FLQVFi4Jlmd
; for pseudocode and rationale.

; napu per ndau
NDAU = 100000000

MIN_SELF_STAKE = 100000000000    ; 1000 ndau
MAX_LEVERAGE = 3
MAX_AGGREGATE_STAKE = 5000000000000 ; 50,000 ndau

NINETY_DAY = 7776000000000      ; 60 * 60 * 24 * 90 * 1_000_000

RESOLVE_STAKE_BASE = 500000000   ; 5 ndau
RESOLVE_STAKE_V_N = 5
RESOLVE_STAKE_V_D = 100

;; tx field accessors
TARGET = 3
STAKE_TO = 5
RULES = 8
QTY = 11

handler EVENT_DEFAULT {
    fail
}

handler EVENT_STAKE {
                                    ; primary rules stakeTo target tx aggregate from_primary from_target
    pick 3                          ; primary rules stakeTo target tx aggregate from_primary from_target tx
    call is_primary                 ; primary rules stakeTo target tx aggregate from_primary from_target is_primary
    pick 8                          ; primary rules stakeTo target tx aggregate from_primary from_target is_primary primary
    pick 5                          ; primary rules stakeTo target tx aggregate from_primary from_target is_primary primary tx
    call is_primary_self_stake      ; primary rules stakeTo target tx aggregate from_primary from_target is_primary is_pss
    or                              ; primary rules stakeTo target tx aggregate from_primary from_target (is_primary || is_pss)
    ifnz
        ;; in this case we depend only on the relations
        ;; however, we need to define the relational rules
        ;; we need from_external, from_primary
        ;; from_external = aggregate - from_primary
        ;; from_primary = from_primary + tx.qty

                                    ; primary rules stakeTo target tx aggregate from_primary from_target
        pick 2                      ; primary rules stakeTo target tx aggregate from_primary from_target aggregate
        pick 2                      ; primary rules stakeTo target tx aggregate from_primary from_target aggregate from_primary
        sub                         ; primary rules stakeTo target tx aggregate from_primary from_target from_external
        pick 2                      ; primary rules stakeTo target tx aggregate from_primary from_target from_external from_primary
        pick 5                      ; primary rules stakeTo target tx aggregate from_primary from_target from_external from_primary tx
        field QTY                   ; primary rules stakeTo target tx aggregate from_primary from_target from_external from_primary qty
        add                         ; primary rules stakeTo target tx aggregate from_primary from_target from_external from_primary
        call relations_hold         ; primary rules stakeTo target tx aggregate from_primary from_target relations_hold
        not                         ; invert relations_hold to return 0 for success
        ret
    endif

    ;; if primary staker isn't set, we just accept it
                                    ; primary rules stakeTo target tx aggregate from_primary from_target
    over                            ; primary rules stakeTo target tx aggregate from_primary from_target from_primary
    zero                            ; primary rules stakeTo target tx aggregate from_primary from_target from_primary 0
    eq                              ; primary rules stakeTo target tx aggregate from_primary from_target (from_primary == 0)
    ifnz
        zero
        ret
    endif

    ;; we need the relations, but with from_external == aggregate - from_primary + tx.qty
                                    ; primary rules stakeTo target tx aggregate from_primary from_target
    pick 2                          ; primary rules stakeTo target tx aggregate from_primary from_target aggregate
    pick 2                          ; primary rules stakeTo target tx aggregate from_primary from_target aggregate from_primary
    sub                             ; primary rules stakeTo target tx aggregate from_primary from_target (aggregate - from_primary)
    pick 4                          ; primary rules stakeTo target tx aggregate from_primary from_target (aggregate - from_primary) tx
    field QTY                       ; primary rules stakeTo target tx aggregate from_primary from_target (aggregate - from_primary) qty
    add                             ; primary rules stakeTo target tx aggregate from_primary from_target from_external
    pick 2                          ; primary rules stakeTo target tx aggregate from_primary from_target from_external from_primary
    call relations_hold             ; primary rules stakeTo target tx aggregate from_primary from_target relations_hold
    not                             ; 0 indicates success as a return code
}

func is_primary(1) {
                                    ; tx
    dup                             ; tx tx
    field STAKE_TO                  ; tx stake_to
    swap                            ; stake_to tx
    field RULES                     ; stake_to rules
    eq
}

func is_primary_self_stake(2) {
                                    ; primary tx
    field TARGET                    ; primary target
    eq
}

func relations_hold(2) {
    ;; from_primary >= MIN_SELF_STAKE
                                    ; from_external from_primary
    dup                             ; from_external from_primary from_primary
    push MIN_SELF_STAKE             ; from_external from_primary from_primary MIN_SELF_STAKE
    lt                              ; from_external from_primary (from_primary<MIN_SELF_STAKE)
    ifnz
        false
        ret
    endif

    ;; from_primary * MAX_LEVERAGE >= from_external
                                    ; from_external from_primary
    dup                             ; from_external from_primary from_primary
    push MAX_LEVERAGE               ; from_external from_primary from_primary MAX_LEVERAGE
    mul                             ; from_external from_primary (from_primary*MAX_LEVERAGE)
    pick 2                          ; from_external from_primary (from_primary*MAX_LEVERAGE) from_external
    lt                              ; from_external from_primary ((from_primary*MAX_LEVERAGE)<from_external)
    ifnz
        false
        ret
    endif

    ;; from_external + from_primary <= MAX_AGGREGATE_STAKE
                                    ; from_external from_primary
    add                             ; (from_external+from_primary)
    push MAX_AGGREGATE_STAKE        ; (from_external+from_primary) MAX_AGGREGATE_STAKE
    gt                              ; ((from_external+from_primary)>MAX_AGGREGATE_STAKE)
    not                             ; ((from_external+from_primary)<=MAX_AGGREGATE_STAKE)
}
